
- annotation 정리
@Entity : 이 클래스를 테이블과 매핑시킬게하는 정보
@Table(name="MEMBER") : 테이블 이름 매핑
@ID: PK 를 의미
@Column(name = "ID") 테이블 칼럼명 제공

- 영속성
 1. 영속성 컨텍스트 : 엔티티(테이블에 대응하는 하나의 클래스)를 영구 저장화는 환경
 2. 엔티티 생명주기
  #비영속 : 엔티티를 엔티티 매니저에 저장하지 않은상태
  #영속 : 엔티티를 entity 매니저에 저장한상태 ( entityManger.persist )
  #준영속 : 영속성 컨텍스트에서 미관리 ( entityManger.detach/close/clear )
  #삭제 : 영속성 컨텍스트에서 삭제 ( entityManger.remove )
 3. 영속성 컨텍스트 특징
  #엔티티에 @Id(기본키) 식별자 값이 반드시 있어야함.(아닐경우, 예외)
  #트랜잭션 커밋시, db에 커밋을 진행한다.(flush 라고 칭함)
  #영속성 컨텍스트 사용시 장점
   > 1차캐시 : 영속 상태 엔티티는 이곳에 저장 된다. @Id 가 key로 저장 value는 엔티티obj 저장되는 형태
              데이터가 있으면 1차캐시(메모리)에서 리턴, 없으면 db에서 꺼내서 1차캐시에 저장한다.
   > 동일성 보장 : 1차 캐시에서 가져오므로, 영속 엔티티의 동일성을 보장한다.(다른데서 업데이트 치면 어떻게 될지 확인해보기)
   > 쓰기 지연 : persist 시, insert문을 쓰기지연SQL 저장소에 저장했다가, commit시 실제 db에 날린다(flush).
   > 변경 감지 : 엔티티 변경을 감지한다.(엔티티로 등록된 객체를 set 할때), 변경감지는 영속 상태의 엔티티만 적용됌
                ■순서 : 1.트랜잭션 커밋시, 엔티티 매니저 내부에서 flush 실행하면서, 변경된 엔티티가 있는지 확인!
                       2.기존 엔티티와 스냅샷을 비교, 변경된 엔티티를 찾음
                       3.변경된 엔티티가 있으면 수정쿼리 생성, 쓰기 지연 sql 저장소에 보냄
                       4. db 트랜잭션 커밋!
   > 지연 로딩 :
  #플러시 : 영속성 컨텍스트의 변경 내용을 db에 반영
   > 말에 어폐가 있음. em.persist(mem1), em.persist(mem2) 한다음 JPQL 실행 하면 플러시가 된다고했는데
     JPQL 실행후 db조회시, 실제로는 db 저장이 안되어있음.
  #준영속 : 영속성 컨텍스트에서 미관리
           ■준영속성으로 만드는 방법
           1)entityManger/detach(entity) : 특정 엔티티만 준영속 상태로 만든다
            > 특정 엔티티의 쓰기지연SQL 저장소, 1차캐시에 모든정보가 제거된다.
           2)entityManger.clear() : 영속성 컨텍스트를 완전히 초기화
            > 모든 쓰기지연SQL 저장소, 1차캐시 전부 삭제처리~
           3)entityManger.close() : 영속성 컨텍스트 종료!
            > 영속성 컨텍스트가 아예 삭제됌 (emf.createEntityManager(); //엔티티 매니저 생성의 반대)

           ■특징

