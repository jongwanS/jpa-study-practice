
- annotation 정리
@Entity : 이 클래스를 테이블과 매핑시킬게하는 정보
@Table(name="MEMBER") : 테이블 이름 매핑
@ID: PK 를 의미
@Column(name = "ID") 테이블 칼럼명 제공

- 영속성
 1. 영속성 컨텍스트 : 엔티티(테이블에 대응하는 하나의 클래스)를 영구 저장화는 환경
 2. 엔티티 생명주기
  #비영속 : 엔티티를 엔티티 매니저에 저장하지 않은상태
  #영속 : 엔티티를 entity 매니저에 저장한상태 ( entityManger.persist )
  #준영속 : 영속성 컨텍스트에서 미관리 ( entityManger.detach/close/clear )
  #삭제 : 영속성 컨텍스트에서 삭제 ( entityManger.remove )
 3. 영속성 컨텍스트 특징
  #엔티티에 @Id(기본키) 식별자 값이 반드시 있어야함.(아닐경우, 예외)
  #트랜잭션 커밋시, db에 커밋을 진행한다.(flush 라고 칭함)
  #영속성 컨텍스트 사용시 장점
   > 1차캐시 : 영속 상태 엔티티는 이곳에 저장 된다. @Id 가 key로 저장 value는 엔티티obj 저장되는 형태
              데이터가 있으면 1차캐시(메모리)에서 리턴, 없으면 db에서 꺼내서 1차캐시에 저장한다.
   > 동일성 보장 : 1차 캐시에서 가져오므로, 영속 엔티티의 동일성을 보장한다.(다른데서 업데이트 치면 어떻게 될지 확인해보기)
   > 쓰기 지연 : persist 시, insert문을 쓰기지연SQL 저장소에 저장했다가, commit시 실제 db에 날린다(flush).
   > 변경 감지 : 엔티티 변경을 감지한다.(엔티티로 등록된 객체를 set 할때), 변경감지는 영속 상태의 엔티티만 적용됌
                ■순서 : 1.트랜잭션 커밋시, 엔티티 매니저 내부에서 flush 실행하면서, 변경된 엔티티가 있는지 확인!
                       2.기존 엔티티와 스냅샷을 비교, 변경된 엔티티를 찾음
                       3.변경된 엔티티가 있으면 수정쿼리 생성, 쓰기 지연 sql 저장소에 보냄
                       4. db 트랜잭션 커밋!
   > 지연 로딩 :
  #플러시 : 영속성 컨텍스트의 변경 내용을 db에 반영
  #준영속 : 영속성 컨텍스트에서 미관리
          ■준영속성으로 만드는 방법
           1)entityManger/detach(entity) : 특정 엔티티만 준영속 상태로 만든다
           > 특정 엔티티의 쓰기지연SQL 저장소, 1차캐시에 모든정보가 제거된다.
           2)entityManger.clear() : 영속성 컨텍스트를 완전히 초기화
            > 모든 쓰기지연SQL 저장소, 1차캐시 전부 삭제처리~
           3)entityManger.close() : 영속성 컨텍스트 종료!
            > 영속성 컨텍스트가 아예 삭제됌 (emf.createEntityManager(); //엔티티 매니저 생성의 반대)

 4. 엔티티 매핑
  #객체/테이블 매핑 : @Entity, @Table
  #기본 키 매핑 : @Id
  #필드/컬럼 매핑 : @Column
  #연관관계 매핑 : @ManyToOne, @JoinColumn

 - 어노테이션 정리
  #@Entity : 테이블과 매핑(다른 패키지 같은 @Entity 클래스가 있을경우, 이름 지정 필요) 기본값 : 클래스명 그대로 사용
   > 기본생성자 필수(public, protected), 자바는 클래스 생성시 기본 생성자를 만들기 때문 넣어주지 않아도 된다.
   > final 클래스, enum, interface, inner 클래스 사용 불가
   > 저장할 필드에 final 사용하면 안 된다.

   한마디로 이야기하자면, @Entity를 class에 붙이면 JPA가 관리하도록 만들어줌!
  #@Table : 매핑할 테이블 지정
   > name : 매핑할 테이블 이름을 지정
   > catalog
   > schema
   > uniqueConstraints

  #@Column : DB 칼럼으로 선언!
   > @Column(name = "NAME", nullable = false, length = 10)
     설명 : DB 칼럼 속성선언 : "NAME" 으로 사용, null 불가, length 10이다.

  #@Id : 기본키 매핑!
   > 직접할당 : 어플리케이션에서 할당 (obj.set 형태)
   > 자동생성 : 외부에서 생성
     생성법: @GeneratedValue 추가하면 된다.
    1) IDENTITY : DB에 위임
      ■ Mysql 의 AUTO_INCREMENT 등 에 사용
        ex) @GeneratedValue(strategy = GenerationType.IDENTITY)
    2) SEQUENCE : DB 시퀀스를 사용, 기본키 할당
      ■ Oracle, h2 db 에서 시퀀스 사용
        팁 : allocationSize이 50개면, was별로 sequence 50개씩 미리 채번을 하여
             jvm각 컨테이너별로 미리 시퀀스를 선점하므로 겹치지 않을수 있다.
        ex) @SequenceGenerator(
                    name = "BOARD_SEQ_GENERATOR", //식별자 생성기 이름
                    sequenceName = "BOARD_SEQ", //시퀀스 명!
                    initialValue = 1, allocationSize = 1//몇개씩 증가 시킬지
            )
            @id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR")
    3) TABLE : 키 생성 테이블 사용(table에 개발자가 키를 미리 따놓고 사용하는 방식)
        ex) @GeneratedValue(strategy = GenerationType.TABLE)
    4) AUTO : JPA(DB벤더를 판단하여)가 자동생성 전략중 알아서 선택해줌!






